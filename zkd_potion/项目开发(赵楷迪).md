# 🔺✨ Day one

## (一)  实现对话框保存用户数据传至App数组

需求: 点击Main增加接口按钮时，弹出对话框， 用户输入数据后将数据保存至对应的数组

**思路：** 

1. 在mainUse文件夹中的diaLog组件 使用 element组件对话框
2. 在Main父组件中点击按钮后定义方法， 将Visble布尔值改为true并传入diaLog组件
3. 组件显示后, 弹出对应对话框后，用户输入确定后将数据利用事件总线    emit 事件
4. App.vue根组件中 on 事件  并将对象 使用展开运算符赋值对象， 并将push保存至数组



### 1. diaLog组件使用对话框

在对话框中使用form标签， 为需要填写或选择的表单  （见文件- MainUse - dialog.vue

```ts
<el-dialog
      title="增加接口"
      :visible.sync="dialogVisible"
      width="25%"
      :showClose="false"
    >
      <el-form :model="form" label-width="80px" ref="form">
        <el-form-item label="ID:" prop="id" :rules="rules.id">
          <el-input v-model="form.id"></el-input>
        </el-form-item>

        <el-form-item label="Name:" prop="name" :rules="rules.name">
          <el-input v-model="form.name"></el-input>
        </el-form-item>

        <el-form-item label="API:" prop="api" :rules="rules.api">
          <el-input v-model="form.api"></el-input>
        </el-form-item>

        <el-form-item label="Done:" prop="done" :rules="rules.done">
          <el-select v-model="form.done" placeholder="请选择">
            <el-option label="true" value="true"></el-option>
            <el-option label="false" value="false"></el-option>
          </el-select>
        </el-form-item>

        <el-form-item label="Method:" prop="method" :rules="rules.method">
          <el-select
            v-model="form.method"
            placeholder="请选择"
            class="custom-select"
          >
            <el-option label="GET" value="GET"></el-option>
            <el-option label="POST" value="POST"></el-option>
          </el-select>
        </el-form-item>
      </el-form>
      <span slot="footer" class="dialog-footer">
        <el-button
          type="danger"
          @click="dialogVisible = false"
          class="custom-select"
          >取 消</el-button
        >
        <el-button type="primary" @click="uploadForm">确 定</el-button>
      </span>
    </el-dialog>
```



#### 1.1  diaLog组件中 form 规则的设置

```ts
      rules: {
        id: [{ required: true, message: "请输入ID", trigger: "blur" }],
        name: [{ required: true, message: "请输入Name", trigger: "blur" }],
        api: [{ required: true, message: "请输入API", trigger: "blur" }],
        done: [{ required: true, message: "请选择Done", trigger: "change" }],
        method: [
          { required: true, message: "请选择Method", trigger: "change" },
        ],
      },
```



#### 1.2  使用bus总线emit 事件， 将表格数据传出

**bus总线已定义在 Bus文件夹内**

```ts
methods: {
    uploadForm() {
      this.dialogVisible = false;

      Bus.$emit("uploadForm", this.form);
    },
  },
```



### 2. 父组件- Main引入组件dia-Log

为新增接口绑定事件， 并ref绑定dia-Log实例， 当点击按钮式， 将对话框显示， 并在数据触发后， 对表单进行一个数据清空

```ts
<button @click="openDialog">新增接口</button>
<dia-log ref="diaLogRef"></dia-log>

methods: {
openDialog() {
const LogRef = this.$refs.diaLogRef;
LogRef.dialogVisible = true;

// 并在每次点击清空上次的表格填写内容
Object.keys(LogRef.form).forEach((item) => {
LogRef.form[item] = "";
});
},
```



### 3. App 使用事件总线，on事件并将对象数据push数组

当使用引用传递时， 在下一个的新增接口，会对之前的数据影响

所以需要使用：**展开运算符转换为 值传递**

```ts
 created() {
    // 监听自定义事件，并处理传递的数据
    Bus.$on("uploadForm", (formData) => {
      const copiedForm = { ...formData }; // 使用展开运算符创建一个新的对象副本
      this.testArr.push(copiedForm);
    });
  },
};
```



## （二） 其它修改

主要对浏览器缩小进行了修改， 因为缩小时换行，导致整行数据换行 混合一起

- 主要对样式进行处理， 溢出处理

```ts
  /* 此部分暂时解决 缩小时, 文本溢出换行 */
  white-space: nowrap; /* 防止换行 */
  overflow: hidden; /* 超出部分隐藏 */
  text-overflow: ellipsis; /* 超出部分显示省略号 */
```



样式调整后， 在浏览器缩小还是会出现对不齐的情况





## 💓🐟 bug记录

解决过程： 

**问题：**

- bus总线 有毛病： 
  每次的监听都为独立的事件
  	每次的点击都会影响上次的数据
- 如果解绑时却会导致只能监听触发一次



💓🐟 ：传递的时候引用传递， 应该使用值传递



### 未解决 - 预解决的bug -- 

未解决：  

1. Main中对应 文本 样式的调整    (对齐 )
2. diaLog样式的调整，（样式好丑）， select的宽度与输入框不一致， 弹出对话框样式解决不了， 原想设置整体透明度为70%， 四角为弧度~ 
3. 规则的rules应用， 原先想设置对话框的确定键需用户通过验证才可点击确定， 想通过ref获取Log组件事件，去进行验证，但是行不通... 



### （三） 功能实现- 编辑按钮

需求： 当点击编辑时，需要获取当前行的数据， 并且将当前的diaLog弹窗打开， 并且弹窗内容需要是对应的数据，当ID一致时，原数组已存在时，则进行覆盖上传， 否则进行新建， （ID/Index 为数组唯一标识量）

**思路：** 

1. 当点击编辑时， 使用diaLogRef弹窗打开， 并对数据进行回显
2. 将原数组对应下标的 Form展开运算符去进行赋值给Form
3. 当用户点击确认复用原bus总线， bus总线新建一层判断
4. 当ID一致时， 原本数据进行一个覆盖上传



### 1. Main组件为CLick绑定事件， 获取数组数据、数据回显

1. 设置中间变量isEditMode,编辑模式，此值用于传入diaLog组件锁定  Id不可修改，（保证修改为当前行数据）
2. 根据ID（此值唯一）， 获取数组对应对象数据，浅拷贝后传入并使用OpenDiaLog函数
3. 重新调用OpenDiaLog, 弹窗显示



```ts
<dia-log ref="diaLogRef" 
:isEditMode="isEditMode"
@clickDowned = "handleClickDown"
></dia-log>

openDialog(val) {
    const LogRef = this.$refs.diaLogRef;
    LogRef.dialogVisible = true;

    // 并在每次点击清空上次的表格填写内容

    // 未处于编辑时，清空上次对话
    if (this.isEditMode == false) {
        Object.keys(LogRef.form).forEach((item) => {
            LogRef.form[item] = "";
        });
    }
    // 处于编辑状态， 将数组数据 赋值给当前对话 /数据回显
    else {
        console.log("11");
        LogRef.form = val;
    }
},

    
EditArr(val) {
    const GoalItem = { ...this.$props.testArr[val] };
    this.isEditMode = true;
    this.openDialog(GoalItem);
},
```



### 2. 弹窗确认/取消， 默认将编辑状态改为False（触发事件）

处理后， 只有编辑状态的ID不可编辑， 当新建接口时，Id可编辑

触发父组件事件ClickDowned将 isEditMode 设置为False

​		

**子组件**

```ts
<el-button type="danger" @click="CancelClick" class="custom-select"
>取 消</el-button
>
<el-button type="primary" @click="uploadForm">确 定</el-button>


  methods: {
    uploadForm() {
      this.dialogVisible = false;
      Bus.$emit("uploadForm", this.form);
      this.$emit("clickDowned");
    },
    CancelClick() {
      this.dialogVisible = false;
      this.$emit("clickDowned");
    },
  },

```



**父组件**

```ts
<dia-log ref="diaLogRef" 
:isEditMode="isEditMode"
@clickDowned = "handleClickDown"
></dia-log>

// 响应事件，当用户点击确认或取消时，将EditMode模式改为false
handleClickDown() {
this.isEditMode = false;
}
```



### 3. App根组件， Bus总线对On事件进行处理，数据修改

 **ID的唯一标识性**： 通过Id 修改数据

当用户点击编辑按钮，并修改信息提交后， 在App组件中，使用find方法找到当前表单匹配的对象，此条件也为判断是否为编辑提交状态，并使用assigin方法对数组数据进行**覆盖**

```ts
 created() {
    // 监听自定义事件，并处理传递的数据
    Bus.$on("uploadForm", (formData) => {
      const copiedForm = { ...formData }; // 使用展开运算符创建一个新的对象副本

      // 使用find方法获取匹配到的对象， 根据Id标识
      const existingItem = this.testArr.find(
        (item) => item.id === copiedForm.id
      );
      if (existingItem) {
        // 如果找到对应的元素，进行覆盖
        Object.assign(existingItem, copiedForm);
      } else {
        // 如果没有找到，将新对象添加到数组中
        this.testArr.push(copiedForm);
      }
    });
  },
```



## 💓🐟 Bug记录

isEditMode 标识量的设置异常- 

​	此标识量 用于锁定ID（编辑时改为只读状态）

​	原处理方式，在EditArr方法中，调用openDialog后，将标识量改为fasle, 但是由于事件的异步性， 函数调用时， 已标识量传递为False， 导致打开编辑时ID可修改

​	ID可修改后果：当用户输入的ID值不为当前所处对象ID时， 由于逻辑判断，会变为新建接口



解决：见 （三） 第二点

